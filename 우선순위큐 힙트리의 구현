// 시험 출제 주의 ⭐⭐⭐⭐⭐⭐⭐⭐⭐⭐
// 힙트리
// 완전이진트리
// - 중복허용
// - 최대힙 : 부모 >= 자식 (계층별 정렬)
// - 최소힙 : 부모 <= 자식 (계층별 정렬)
// 위에 것을 알아야 구현 가능 !!
// 부모와 자식 간에만 구분하면 됨 !!
// 여러가지 합한 문제로 나옴 !!
  
#include <stdio.h>
#include<stdlib.h>
#define MAX 200
typedef int element;
typedef struct{
	element heap[MAX];
	int heap_size;//힙트리 구조체 정의
}HeapType;
//현재 요소의 개수가 heap_size인 히프 h에 item 삽입 
void insertMaxHeap(HeapType* h, element item){ // item = 8
	int i;
	i = ++(h->heap_size); // i = 11
	while((i!=1) && (item  > h->heap[i/2])){//삽입노드가 부모보다 크면
		h->heap[i] = h->heap[i/2];// heap[11]  = heap[5]; //부모노드를 삽입위치로 교환
		i= i/2;//i는 부모노드 위치
	} // 자기 부모보다 작을 때까지
	h->heap[i]= item;//hea   p[2] = 8, 새로운 노드 삽입
}
element deleteMaxHeap(HeapType* h){ 
	int parent, child;
	element item, temp;
	item = h->heap[1];//루트노드 반환값
	temp = h->heap[(h->heap_size)--];//말단노드를 저장 3번
	parent = 1;
	child = 2;
	while(child <= h->heap_size){
		//현재 노드의 자식 노드 중 더 큰 자식 노드를 검색
		if (child < h->heap_size && h->heap[child] < h->heap[child+1] )
			child++;
		//검색된 자식노드가 말단노드이면 아래로 이동안함.	
		if (temp >= h->heap[child] ) break; 
		//한단계 아래로 이동
		h->heap[parent] = h->heap[child];//
		parent = child;// parent = 2
		child *= 2; // child = 4
	}
	h->heap[parent] = temp;//
	return item;
}
void printHeap(HeapType* heap){
	for(int i = 1;i<=heap->heap_size;i++)
		printf("[%d]: %d ",i, heap->heap[i]);
	printf("\n");
}
int main(){
	element e1 =10,e2=5,e3=30;
	HeapType* heap = (HeapType*)malloc(sizeof(HeapType));//동적할당;
	heap->heap_size = 0;
	//삽입
	printf("최대힙 삽입\n");
	insertMaxHeap(heap,e1);	printHeap(heap);
	insertMaxHeap(heap,e2);	printHeap(heap);
	insertMaxHeap(heap,e3);	printHeap(heap);

	//삭제
	printf("최대힙 삭제\n");
	printHeap(heap);
	deleteMaxHeap(heap);	printHeap(heap);
	deleteMaxHeap(heap);	printHeap(heap);
	deleteMaxHeap(heap);	printHeap(heap);
	free(heap);
	return 0;
}
